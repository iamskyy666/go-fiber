```go
package main

import (
	"fmt"
	"log"

	"github.com/gofiber/fiber/v2"
)


func main() {
	app := fiber.New()
	
app.Post("/sign-in", func(ctx *fiber.Ctx) error {
	// FormValue returns the first value by key from a MultipartForm.
	username:=ctx.FormValue("username")
	password:=ctx.FormValue("password")

	if username!="skyy" || password !="skyy1234"{
		return ctx.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
			"message":"‚ö†Ô∏è You are not authorized!",
		})
	}

	return ctx.Status(fiber.StatusOK).JSON(fiber.Map{
		"message":"üü¢ Welcome!",
	})


})
	fmt.Println("Server Up N Running.. ‚úÖ")
	log.Fatal(app.Listen(":3000"))
}

// for-fields on postman/thunder-client, not body!
// {
//   "message": "üü¢ Welcome!"
// }
```
```go
package main

import (
	"fmt"
	"log"

	"github.com/gofiber/fiber/v2"
)


func main() {
	app := fiber.New()
	
app.Post("/upload-document", func(ctx *fiber.Ctx) error {
	// FormFile returns the first file by key from a MultipartForm.
	// SaveFile saves any multipart file to disk.
	
	file,err:=ctx.FormFile("document")
	if err!=nil{
		return err
	}

	return ctx.SaveFile(file,fmt.Sprintf("./%s",file.Filename))


})
	fmt.Println("Server Up N Running.. ‚úÖ")
	log.Fatal(app.Listen(":3000"))
}
```

```go
// Multipart
package main

import (
	"fmt"
	"log"
	"time"

	"github.com/gofiber/fiber/v2"
)


func main() {
	app := fiber.New()
	
app.Post("/upload-doc", func(c *fiber.Ctx) error {
  // Parse the multipart form:
  if form, err := c.MultipartForm(); err == nil {
    // => *multipart.Form

    // Get all files from "documents" key:
    files := form.File["documents"]
    // => []*multipart.FileHeader

    // Loop through files:
    for _, file := range files {
      //name:=fmt.Sprintf(file.Filename, file.Size, time.Now().String())
      // => "tutorial.pdf" 360641 "application/pdf"

      // Save the files to disk:
      if err := c.SaveFile(file, fmt.Sprintf("./%s", time.Now().String())); err != nil {
        return err
      }
    }
    return err
  }
  return c.SendStatus(fiber.StatusOK)
})
	fmt.Println("Server Up N Running.. ‚úÖ")
	log.Fatal(app.Listen(":3000"))
}

```
Let‚Äôs go deep into **`Locals` in Go Fiber**, because it‚Äôs one of those features that looks small but is *extremely* powerful for building clean, modular middleware and handlers.

We‚Äôll unpack **what it is**, **why we need it**, **how it works under the hood**, and **how to use it safely and effectively** in real apps like our Go-Fiber + React fullstack project.

---

## üß† What is `Locals` in Fiber?

`Locals` are **context-local variables** ‚Äî key-value pairs we attach to the `fiber.Ctx` object during a request.
They live **only for the lifetime of that single HTTP request**.

Think of it like a **temporary data bag** or **per-request storage** shared across middlewares and handlers.

So while `fiber.Ctx` represents ‚Äúthis request,‚Äù
`Locals` represents ‚Äúdata tied to this request that we want to share internally.‚Äù

---

## ‚öôÔ∏è Analogy (simplified)

| Context      | Example                                           |
| ------------ | ------------------------------------------------- |
| HTTP Request | User requests `/tasks`                            |
| Middleware   | We verify their JWT, extract `userId`             |
| Locals       | We store `userId` inside `c.Locals("userId", id)` |
| Handler      | Later, we read it back using `c.Locals("userId")` |

‚úÖ No globals, no thread-safety issues, no data leaks ‚Äî everything stays inside the request.

---

## üß© Syntax

Fiber exposes two methods on the context (`*fiber.Ctx`):

```go
func (c *Ctx) Locals(key string, value ...any) any
```

* **Setter:** `c.Locals("key", value)`
* **Getter:** `c.Locals("key")`

Example:

```go
c.Locals("userId", 42) // store
id := c.Locals("userId").(int) // retrieve (type assert)
```

---

## üîç Example 1 ‚Äî Basic Middleware Communication

Let‚Äôs see how one middleware can set data, and the handler can read it.

```go
app := fiber.New()

// Middleware to add request start time
app.Use(func(c *fiber.Ctx) error {
    c.Locals("startTime", time.Now())
    return c.Next() // pass control
})

// Handler
app.Get("/", func(c *fiber.Ctx) error {
    start := c.Locals("startTime").(time.Time)
    duration := time.Since(start)
    return c.SendString(fmt.Sprintf("Request took %v", duration))
})

app.Listen(":3000")
```

‚úÖ Here, `Locals` acts like a ‚Äúshared memory‚Äù between middleware and handler ‚Äî clean, isolated per request.

---

## üîë Example 2 ‚Äî Authentication Middleware

A very common use case in real projects.

### Step 1: Middleware validates JWT

```go
func AuthMiddleware(c *fiber.Ctx) error {
    token := c.Get("Authorization")
    userID, err := ValidateToken(token)
    if err != nil {
        return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{
            "error": "invalid token",
        })
    }
    // store userID in locals
    c.Locals("userId", userID)
    return c.Next()
}
```

### Step 2: Protected route accesses Locals

```go
app.Get("/tasks", AuthMiddleware, func(c *fiber.Ctx) error {
    userID := c.Locals("userId").(string)
    tasks := GetTasksForUser(userID)
    return c.JSON(tasks)
})
```

‚úÖ The handler doesn‚Äôt need to know how authentication works; it just reads from `Locals`.

---

## üîÅ Example 3 ‚Äî Chained middlewares

`Locals` can pass data between multiple middlewares too:

```go
func First(c *fiber.Ctx) error {
    c.Locals("msg", "Hello")
    return c.Next()
}

func Second(c *fiber.Ctx) error {
    msg := c.Locals("msg").(string)
    msg += " Fiber!"
    c.Locals("msg", msg)
    return c.Next()
}

func Final(c *fiber.Ctx) error {
    return c.SendString(c.Locals("msg").(string))
}

app.Use(First, Second)
app.Get("/", Final)
```

Output ‚Üí `Hello Fiber!`

---

## üß† Under the hood

* `Locals` is implemented as a map inside Fiber‚Äôs context structure.
* It‚Äôs local to the request ‚Äî once the request finishes, Fiber reuses the context object but resets its locals map.
* Thread-safe because each request runs on its own goroutine and has its own context.

So there‚Äôs **no race condition** and **no need for locks**.

---

## ‚ö° Advanced ‚Äî Passing complex data

We can store any Go type:

```go
type User struct {
    ID   int
    Name string
}

c.Locals("user", User{ID: 1, Name: "Skyy"})
u := c.Locals("user").(User)
fmt.Println(u.Name) // "Skyy"
```

We can even store structs, DB handles, or slices for request-scoped caching ‚Äî but avoid storing global resources (like DB connections).

---

## üß± Common Use Cases

| Use Case       | Example                                     |
| -------------- | ------------------------------------------- |
| Authentication | Store user ID / role after JWT validation   |
| Authorization  | Store permissions for later route check     |
| Logging        | Store request metadata (trace ID, user ID)  |
| Request timing | Store start time for latency measurement    |
| Localization   | Store user language / region for i18n       |
| Request ID     | Store a unique UUID per request for tracing |
| Caching        | Store small precomputed values              |

---

## üß© Example ‚Äî Add Request ID Middleware

```go
app.Use(func(c *fiber.Ctx) error {
    reqID := uuid.New().String()
    c.Locals("requestId", reqID)
    c.Set("X-Request-ID", reqID)
    return c.Next()
})

app.Get("/", func(c *fiber.Ctx) error {
    id := c.Locals("requestId").(string)
    return c.SendString("Request ID: " + id)
})
```

‚úÖ Great for distributed tracing and debugging logs.

---

## ‚ö†Ô∏è Best Practices

1. **Keep keys short but unique:**
   Use `"userId"` or `"auth.user"` style ‚Äî avoid collisions between middlewares.

2. **Type safety:**
   Always type assert carefully. Consider using small helper functions to avoid repetitive casting:

   ```go
   func GetUserID(c *fiber.Ctx) (string, bool) {
       id, ok := c.Locals("userId").(string)
       return id, ok
   }
   ```

3. **Don‚Äôt store large objects:**
   Locals are per-request ‚Äî avoid big structs or file buffers.

4. **Avoid global mutable state:**
   Locals is *per request*, not global ‚Äî it‚Äôs safe, but don‚Äôt misuse it for app-wide data.

5. **Middleware order matters:**
   Set Locals before calling `Next()`, so subsequent middlewares/handlers can use it.

---

## üß™ Example ‚Äî Combining everything

```go
app := fiber.New()

// Authentication middleware
app.Use(func(c *fiber.Ctx) error {
    token := c.Get("Authorization")
    userID := "user_123" // suppose verified
    c.Locals("userId", userID)
    return c.Next()
})

// Logger middleware
app.Use(func(c *fiber.Ctx) error {
    start := time.Now()
    err := c.Next()
    userID := c.Locals("userId")
    fmt.Printf("User %v took %v to access %v\n", userID, time.Since(start), c.Path())
    return err
})

app.Get("/tasks", func(c *fiber.Ctx) error {
    userID := c.Locals("userId").(string)
    return c.SendString("Tasks for user: " + userID)
})

app.Listen(":3000")
```

---

## üß≠ TL;DR ‚Äî Summary Table

| Concept       | Description                                         |
| ------------- | --------------------------------------------------- |
| `Locals`      | Per-request key-value store attached to `fiber.Ctx` |
| Lifetime      | Exists only during a single HTTP request            |
| Scope         | Middleware ‚Üí Handler communication                  |
| Type          | `map[string]interface{}` internally                 |
| Setter        | `c.Locals("key", value)`                            |
| Getter        | `val := c.Locals("key")`                            |
| Use cases     | Auth, logs, tracing, language, timing               |
| Thread-safety | Safe ‚Äî context is per request                       |
| Best practice | Use small typed values and helper functions         |

---

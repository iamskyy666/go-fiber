# ðŸ§© What is Fiber?

**Fiber** is a **web framework for Go (Golang)** built on top of **`fasthttp`**, the fastest HTTP engine in Go.

> ðŸŸ¢ Think of Fiber as **Express.js for Go** â€” itâ€™s designed to feel familiar if weâ€™ve worked with Node.js/Express before.

Its full name is **Go Fiber**, and itâ€™s maintained under the module:

```
github.com/gofiber/fiber/v2
```

---

# âš™ï¸ Why Fiber was created

Goâ€™s built-in `net/http` package is solid and minimal, but:

* Itâ€™s a bit low-level for building REST APIs quickly.
* It doesnâ€™t include built-in features like routing groups, middleware chains, static file serving, etc.
* The `fasthttp` library was created to solve **performance bottlenecks** â€” itâ€™s much faster but not fully compatible with `net/http`.

ðŸ‘‰ So Fiber was built **on top of fasthttp** to combine:

* The **speed** of fasthttp,
* The **ease of use** of Express.js.

---

# ðŸš€ Core features of Fiber

| Feature                       | Description                                                                 |
| ----------------------------- | --------------------------------------------------------------------------- |
| âš¡ **Fast performance**        | Built on top of `fasthttp`, one of the fastest HTTP engines for Go.         |
| ðŸ§± **Express-like syntax**    | Familiar API (`app.Get`, `app.Post`, `app.Use`, etc.).                      |
| ðŸ”— **Middleware support**     | Easy middleware chaining, like logging, CORS, JWT, etc.                     |
| ðŸ§ **Routing groups**         | Organize routes logically (e.g., `/api/v1/users`).                          |
| ðŸ“¦ **Static file serving**    | Serve React build files or images easily.                                   |
| ðŸ§  **Context-based API**      | Each request has its own `fiber.Ctx`, similar to Expressâ€™s `req` and `res`. |
| ðŸ§° **Built-in utilities**     | JSON handling, cookies, file uploads, etc.                                  |
| ðŸ” **Third-party middleware** | Ready-to-use official middlewares (e.g., CORS, compression, JWT).           |

---

# ðŸ§  Fiber Architecture Overview

```
HTTP Request
    â†“
fasthttp engine (low-level)
    â†“
Fiber Context (fiber.Ctx)
    â†“
Middleware Chain (logging, auth, cors, etc.)
    â†“
Route Handler
    â†“
Response written to client
```

Everything flows through the `fiber.Ctx` (context object) â€” which holds the request, response, params, body, etc.

---

# ðŸ§© Fiber Project Setup

## Step 1. Initialize Go module

```bash
go mod init myapp
```

## Step 2. Install Fiber

```bash
go get github.com/gofiber/fiber/v2
```

## Step 3. Basic example (`main.go`)

```go
package main

import "github.com/gofiber/fiber/v2"

func main() {
	app := fiber.New() // create new Fiber instance

	app.Get("/", func(c *fiber.Ctx) error {
		return c.SendString("Hello, Fiber ðŸ‘‹")
	})

	app.Listen(":3000")
}
```

Run:

```bash
go run main.go
```

Visit **[http://localhost:3000](http://localhost:3000)**

---

# ðŸ”§ Core Concepts

Letâ€™s explore Fiberâ€™s most important building blocks ðŸ‘‡

---

## 1ï¸âƒ£ `fiber.App` â€” The main application instance

It represents our web server.
We create it using:

```go
app := fiber.New()
```

We can also pass configuration options:

```go
app := fiber.New(fiber.Config{
    AppName: "Task Manager API",
})
```

---

## 2ï¸âƒ£ `fiber.Ctx` â€” The Context

Every route handler receives a **context object (`c *fiber.Ctx`)** that represents the current request.

We use it to:

* Read data â†’ `c.Params()`, `c.Query()`, `c.Body()`, `c.Get()`
* Write response â†’ `c.SendString()`, `c.JSON()`, `c.Status()`
* Manage cookies, headers, etc.

Example:

```go
app.Post("/login", func(c *fiber.Ctx) error {
	data := new(User)
	if err := c.BodyParser(data); err != nil {
		return c.Status(400).JSON(fiber.Map{"error": "Invalid body"})
	}
	return c.JSON(fiber.Map{"message": "Welcome " + data.Username})
})
```

---

## 3ï¸âƒ£ Routing

Fiber has simple route definitions:

```go
app.Get("/users", getUsers)
app.Post("/users", createUser)
app.Put("/users/:id", updateUser)
app.Delete("/users/:id", deleteUser)
```

Route groups (for versioning or modularity):

```go
api := app.Group("/api")
v1 := api.Group("/v1")

v1.Get("/tasks", getTasks)
v1.Post("/tasks", createTask)
```

---

## 4ï¸âƒ£ Middleware

Middlewares are executed **before** the final handler â€” used for logging, auth, etc.

Global middleware:

```go
app.Use(logger.New()) // logs every request
app.Use(cors.New())   // enable CORS
```

Per-route middleware:

```go
app.Get("/admin", isAuthenticated, adminHandler)
```

Example custom middleware:

```go
func isAuthenticated(c *fiber.Ctx) error {
	token := c.Get("Authorization")
	if token == "" {
		return c.Status(401).SendString("Unauthorized")
	}
	return c.Next()
}
```

---

## 5ï¸âƒ£ Static Files

To serve React frontend:

```go
app.Static("/", "./client/dist")
```

This serves files generated by:

```bash
npm run build
```

and lets Fiber handle routes for the React app.

---

## 6ï¸âƒ£ JSON & Body Handling

Fiber can automatically parse JSON:

```go
type Task struct {
	ID    string `json:"id"`
	Title string `json:"title"`
}

app.Post("/task", func(c *fiber.Ctx) error {
	task := new(Task)
	if err := c.BodyParser(task); err != nil {
		return err
	}
	return c.JSON(task)
})
```

---

## 7ï¸âƒ£ Error Handling

Custom error handler:

```go
app := fiber.New(fiber.Config{
	ErrorHandler: func(c *fiber.Ctx, err error) error {
		code := fiber.StatusInternalServerError
		if e, ok := err.(*fiber.Error); ok {
			code = e.Code
		}
		return c.Status(code).JSON(fiber.Map{
			"error": err.Error(),
		})
	},
})
```

---

## 8ï¸âƒ£ Fiber Middlewares (Official)

Commonly used:

```bash
go get github.com/gofiber/fiber/v2/middleware/{cors,logger,recover,jwt,compress}
```

Examples:

```go
app.Use(logger.New())
app.Use(recover.New()) // recover from panics
app.Use(cors.New(cors.Config{
	AllowOrigins: "http://localhost:5173",
	AllowHeaders: "Origin, Content-Type, Accept",
}))
```

---

# ðŸ§± Example Folder Structure (Fullstack Fiber + React)

```
task-manager/
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ main.go
â”‚   â”œâ”€â”€ go.mod
â”‚   â”œâ”€â”€ air.toml
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚    â””â”€â”€ taskRoutes.go
â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚    â””â”€â”€ taskController.go
â”‚   â”œâ”€â”€ models/
â”‚   â”‚    â””â”€â”€ taskModel.go
â”‚   â””â”€â”€ database/
â”‚        â””â”€â”€ connect.go
â”‚
â””â”€â”€ client/
    â”œâ”€â”€ package.json
    â”œâ”€â”€ src/
    â””â”€â”€ dist/
```

---

# ðŸ§  Comparison: Fiber vs Express.js

| Feature        | Express.js (Node) | Fiber (Go)               |
| -------------- | ----------------- | ------------------------ |
| Language       | JavaScript        | Go                       |
| Performance    | Fast              | âš¡ Extremely fast         |
| Type Safety    | Dynamic           | Statically typed         |
| Hot reload     | nodemon           | air                      |
| Middleware     | Tons              | Fewer but efficient      |
| Learning curve | Easy              | Easy if we know Express |
| Concurrency    | Single-threaded   | Multi-threaded natively  |

---

# ðŸ§® Benchmarks

Fiber consistently ranks **among the fastest** Go frameworks â€” handling hundreds of thousands of requests per second.

Because it uses:

* **Zero memory allocations**
* **Efficient request routing**
* **fasthttp** under the hood (which is asynchronous)

---

# ðŸ§© Common Packages to Use with Fiber

| Package     | Purpose                                    |
| ----------- | ------------------------------------------ |
| `gorm`      | ORM for databases (PostgreSQL/MySQL/Mongo) |
| `jwt-go`    | For authentication with JWT tokens         |
| `validator` | For validating request payloads            |
| `godotenv`  | For `.env` configuration                   |
| `air`       | Hot reloading                              |
| `cors`      | Cross-Origin Resource Sharing              |
| `logger`    | Logging middleware                         |

---

# âœ… Typical Startup Command

Development:

```bash
air
```

Production:

```bash
go build -o main && ./main
```

---

# ðŸ§­ Summary

| Concept        | What it Does                       |
| -------------- | ---------------------------------- |
| **Fiber**      | High-performance Go web framework  |
| **fasthttp**   | Underlying HTTP engine             |
| **fiber.Ctx**  | Request/response context           |
| **Middleware** | Run logic before route handlers    |
| **Groups**     | Organize routes logically          |
| **Static**     | Serve frontend files easily        |
| **Air**        | Enables live reloading in dev mode |

---

In Fiber, everything â€” every request, every response, every middleware â€” flows through this **`Ctx` (context)** object.

---

# ðŸ§© What is `fiber.Ctx`?

`fiber.Ctx` (short for **context**) represents the **state of a single HTTP request and response**.

Whenever a client (browser, Postman, frontend app, etc.) sends a request to our server:

* Fiber creates a new `Ctx` object,
* Populates it with information about that request,
* Passes it to our route handler function,
* And after we respond, Fiber reuses or releases that context.

ðŸ‘‰ **Every request has its own context.**

Itâ€™s similar to Express.jsâ€™s `req` and `res` objects combined into one.

---

# ðŸ§  Conceptually

In Express:

```js
app.get("/user/:id", (req, res) => {
  res.json({ id: req.params.id })
})
```

In Fiber:

```go
app.Get("/user/:id", func(c *fiber.Ctx) error {
  return c.JSON(fiber.Map{"id": c.Params("id")})
})
```

Here:

* `c` is the context for this particular request.
* It gives us access to **request data** (params, body, headers, cookies, etc.)
  and **response methods** (send, status, json, redirect, etc.)

---

# âš™ï¸ Anatomy of `fiber.Ctx`

Letâ€™s see what `c` (context) gives us access to:

| Category            | Common Methods                                     | Description                                  |
| ------------------- | -------------------------------------------------- | -------------------------------------------- |
| ðŸ” **Request Info** | `c.Method()`, `c.Path()`, `c.IP()`, `c.Protocol()` | Details about the incoming HTTP request      |
| ðŸ§¾ **Headers**      | `c.Get(key)`, `c.Set(key, value)`                  | Get or set headers                           |
| ðŸ”¢ **Params**       | `c.Params("id")`                                   | Get URL parameters like `/user/:id`          |
| â“ **Query**         | `c.Query("q")`                                     | Get query string params like `?q=go`         |
| ðŸ“¦ **Body**         | `c.Body()`, `c.BodyParser(obj)`                    | Get or parse request body (JSON, form, etc.) |
| ðŸ§ **Cookies**      | `c.Cookies()`, `c.Cookie()`                        | Get or set cookies                           |
| ðŸ”™ **Response**     | `c.SendString()`, `c.JSON()`, `c.Status()`         | Send responses                               |
| ðŸ§  **Flow Control** | `c.Next()`                                         | Move to next middleware                      |
| ðŸ§© **Context Data** | `c.Locals()`, `c.Locals(key, value)`               | Store/retrieve values across middlewares     |

---

# ðŸ§ª Common Usage Examples

Letâ€™s go step by step.

---

## 1ï¸âƒ£ Getting URL Parameters

```go
app.Get("/user/:id", func(c *fiber.Ctx) error {
    id := c.Params("id")
    return c.SendString("User ID: " + id)
})
```

URL:

```
GET /user/42
```

Output:

```
User ID: 42
```

---

## 2ï¸âƒ£ Getting Query Parameters

```go
app.Get("/search", func(c *fiber.Ctx) error {
	query := c.Query("q") // /search?q=task
	return c.SendString("Search for: " + query)
})
```

---

## 3ï¸âƒ£ Reading Request Body

### Example: raw text

```go
app.Post("/echo", func(c *fiber.Ctx) error {
	body := c.Body() // []byte
	return c.Send(body)
})
```

### Example: JSON body â†’ struct

```go
type Task struct {
	Title string `json:"title"`
	Done  bool   `json:"done"`
}

app.Post("/task", func(c *fiber.Ctx) error {
	var task Task
	if err := c.BodyParser(&task); err != nil {
		return c.Status(400).JSON(fiber.Map{"error": "Invalid body"})
	}
	return c.JSON(task)
})
```

---

## 4ï¸âƒ£ Sending JSON Responses

```go
app.Get("/hello", func(c *fiber.Ctx) error {
	return c.JSON(fiber.Map{
		"message": "Hello from Fiber ðŸ‘‹",
		"status":  true,
	})
})
```

Equivalent of Expressâ€™s `res.json({})`.

---

## 5ï¸âƒ£ Setting Response Status Code

```go
return c.Status(201).JSON(fiber.Map{"message": "Created"})
```

or simply:

```go
c.Status(404)
return c.SendString("Not Found")
```

---

## 6ï¸âƒ£ Working with Headers

### Get request header:

```go
token := c.Get("Authorization")
```

### Set response header:

```go
c.Set("X-Custom-Header", "Powered-By-Fiber")
```

---

## 7ï¸âƒ£ Using Cookies

```go
// Set cookie
c.Cookie(&fiber.Cookie{
	Name:  "session_id",
	Value: "abc123",
	Age:   3600,
})

// Get cookie
cookie := c.Cookies("session_id")
```

---

## 8ï¸âƒ£ Redirects

```go
return c.Redirect("/login", fiber.StatusFound)
```

---

## 9ï¸âƒ£ Store custom data with `c.Locals`

Useful in middleware chains:

```go
func AuthMiddleware(c *fiber.Ctx) error {
	c.Locals("userID", "42")
	return c.Next()
}

app.Get("/dashboard", AuthMiddleware, func(c *fiber.Ctx) error {
	userID := c.Locals("userID").(string)
	return c.SendString("User ID: " + userID)
})
```

This lets us pass data between middlewares and handlers.

---

## ðŸ”Ÿ File Upload Handling

```go
app.Post("/upload", func(c *fiber.Ctx) error {
	file, err := c.FormFile("file")
	if err != nil {
		return err
	}
	return c.SaveFile(file, "./uploads/"+file.Filename)
})
```

---

# âš™ï¸ Internal Lifecycle of `Ctx`

Hereâ€™s what happens behind the scenes:

```
Client â†’ Request
         â†“
  Fiber creates *fiber.Ctx
         â†“
  Executes middleware chain
         â†“
  Executes route handler
         â†“
  Writes response via Ctx
         â†“
  Returns response â†’ Client
```

The `Ctx` is reused internally by Fiber to reduce allocations â€” which is part of why Fiber is so fast.
This is why we should **never store `Ctx` in a goroutine** â€” it may get reused after the request ends.

---

# âš ï¸ Important Notes

| Rule                                        | Explanation                                             |
| ------------------------------------------- | ------------------------------------------------------- |
| âŒ Donâ€™t use `Ctx` outside request lifecycle | Fiber reuses context objects for efficiency.            |
| âš ï¸ Always return an error or nil            | Fiber expects an `error` return value for control flow. |
| ðŸ§  Use `fiber.Map` for simple JSON          | Itâ€™s a shorthand for `map[string]interface{}`.          |

---

# ðŸ§© Example: Full CRUD with `Ctx`

```go
app.Post("/tasks", func(c *fiber.Ctx) error {
	var task Task
	if err := c.BodyParser(&task); err != nil {
		return c.Status(400).JSON(fiber.Map{"error": "Invalid body"})
	}

	task.ID = uuid.New().String()
	db.Create(&task)
	return c.Status(201).JSON(task)
})

app.Get("/tasks/:id", func(c *fiber.Ctx) error {
	id := c.Params("id")
	var task Task
	if err := db.First(&task, "id = ?", id).Error; err != nil {
		return c.Status(404).JSON(fiber.Map{"error": "Task not found"})
	}
	return c.JSON(task)
})
```

Here, `c` handles everything â€” params, parsing, and responding.

---

# ðŸ§­ Summary

| Purpose         | Example                           |
| --------------- | --------------------------------- |
| Get route param | `c.Params("id")`                  |
| Get query param | `c.Query("page")`                 |
| Get body        | `c.Body()` / `c.BodyParser(&obj)` |
| Send string     | `c.SendString("OK")`              |
| Send JSON       | `c.JSON(fiber.Map{"ok": true})`   |
| Set status      | `c.Status(404)`                   |
| Get header      | `c.Get("Authorization")`          |
| Set header      | `c.Set("X-Header", "Value")`      |
| Next middleware | `c.Next()`                        |
| Locals storage  | `c.Locals("userID", id)`          |
| File upload     | `c.FormFile("file")`              |

---

Letâ€™s go step by step on how to **download files using Go Fiber** â€” both in simple and real-world ways.

Weâ€™ll cover all cases:

1. ðŸ”¹ Downloading a static/local file
2. ðŸ”¹ Forcing the browser to download (not preview)
3. ðŸ”¹ Downloading dynamic or generated files
4. ðŸ”¹ Handling missing files and security

---

## ðŸ§© 1ï¸âƒ£ Basic File Download â€” using `c.Download()`

Fiber provides a built-in helper called **`c.Download()`**, which makes file downloads extremely easy.

### Example:

```go
package main

import "github.com/gofiber/fiber/v2"

func main() {
	app := fiber.New()

	app.Get("/download", func(c *fiber.Ctx) error {
		return c.Download("./files/report.pdf")
	})

	app.Listen(":3000")
}
```

âž¡ï¸ When we visit
`http://localhost:3000/download`
Fiber will send the file `./files/report.pdf` to the browser.

---

## âš™ï¸ 2ï¸âƒ£ Changing the Downloaded Filename

If we want the file to be downloaded with a **different name**, we can pass a second argument:

```go
return c.Download("./files/report.pdf", "monthly_report.pdf")
```

Even if the original file is `report.pdf`, the browser will prompt a download as `monthly_report.pdf`.

---

## ðŸ“ 3ï¸âƒ£ Serving Files Dynamically (based on params)

Suppose we want users to download files by ID or filename dynamically.

```go
app.Get("/download/:filename", func(c *fiber.Ctx) error {
	filename := c.Params("filename")
	filePath := "./uploads/" + filename

	return c.Download(filePath)
})
```

âž¡ï¸ Example URL:
`http://localhost:3000/download/image.png`
â†’ downloads `./uploads/image.png`

---

## ðŸš¨ 4ï¸âƒ£ Handling Missing or Invalid Files

Always check if the file exists before calling `c.Download()`.
Otherwise, Fiber will throw an internal error.

```go
import (
	"os"
	"github.com/gofiber/fiber/v2"
)

app.Get("/download/:filename", func(c *fiber.Ctx) error {
	filename := c.Params("filename")
	filePath := "./uploads/" + filename

	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		return c.Status(404).SendString("File not found")
	}

	return c.Download(filePath)
})
```

---

## ðŸ§  5ï¸âƒ£ Forcing the Browser to Download (not preview)

Some file types (like `.pdf` or `.jpg`) may open in the browser instead of downloading.
`c.Download()` automatically sets the header:

```
Content-Disposition: attachment; filename="file.pdf"
```

That tells the browser: **â€œdownload this fileâ€**, not â€œopen it inline.â€

You can also set it manually if needed:

```go
c.Set("Content-Disposition", "attachment; filename=myfile.pdf")
return c.SendFile("./files/report.pdf")
```

---

## âš¡ 6ï¸âƒ£ Downloading Files from Another Directory (absolute path)

```go
return c.Download("/absolute/path/to/file.zip")
```

âœ… Fiber supports both relative (`./`) and absolute (`/home/user/...`) paths.

---

## ðŸ“„ 7ï¸âƒ£ Downloading Generated Content (in-memory files)

Sometimes we want to generate a file (e.g., CSV, text, or JSON) dynamically and let users download it.

### Example: Generate and download CSV

```go
app.Get("/export", func(c *fiber.Ctx) error {
	data := "id,name,age\n1,Skyy,29\n2,Aria,26"

	c.Set("Content-Type", "text/csv")
	c.Set("Content-Disposition", "attachment; filename=data.csv")

	return c.SendString(data)
})
```

âž¡ï¸ This will **create and download** a CSV file instantly without writing to disk.

---

## ðŸ§° 8ï¸âƒ£ Downloading Binary Data

If the content is binary (like an image or PDF generated from memory):

```go
app.Get("/pdf", func(c *fiber.Ctx) error {
	pdfBytes := []byte("%PDF-1.4...") // your PDF byte data
	c.Set("Content-Type", "application/pdf")
	c.Set("Content-Disposition", "attachment; filename=generated.pdf")
	return c.Send(pdfBytes)
})
```

---

## ðŸ§© 9ï¸âƒ£ File Download + Authentication Example

In real-world apps, we often protect downloads using JWT or sessions.

```go
app.Get("/secure-download/:file", AuthMiddleware, func(c *fiber.Ctx) error {
	file := c.Params("file")
	path := "./private/" + file

	if _, err := os.Stat(path); os.IsNotExist(err) {
		return c.Status(404).SendString("File not found")
	}

	return c.Download(path)
})
```

âœ… Here the middleware checks auth before allowing download.

---

## ðŸ§  10ï¸âƒ£ Summary Table

| Use Case                | Method                      | Example                                 |
| ----------------------- | --------------------------- | --------------------------------------- |
| Basic file download     | `c.Download()`              | `c.Download("path/to/file.pdf")`        |
| Custom filename         | 2nd arg                     | `c.Download("path.pdf", "newname.pdf")` |
| Dynamic filename        | URL param                   | `c.Params("filename")`                  |
| Force download          | Auto in `c.Download()`      |                                         |
| Check file exists       | `os.Stat()`                 | Avoids 500 errors                       |
| Generate file in memory | `c.SendString()` + headers  | Dynamic CSV, text                       |
| Secure file access      | Middleware + `c.Download()` | Authenticated routes                    |

---

## âš™ï¸ Bonus: Serving vs Downloading

| Function                 | Behavior                          |
| ------------------------ | --------------------------------- |
| `c.SendFile("file.pdf")` | Displays file in browser (inline) |
| `c.Download("file.pdf")` | Forces browser to download file   |

---

## âœ… Example Full Implementation

```go
package main

import (
	"os"
	"github.com/gofiber/fiber/v2"
)

func main() {
	app := fiber.New()

	app.Get("/download/:file", func(c *fiber.Ctx) error {
		filename := c.Params("file")
		path := "./uploads/" + filename

		if _, err := os.Stat(path); os.IsNotExist(err) {
			return c.Status(404).SendString("âŒ File not found")
		}

		return c.Download(path, filename)
	})

	app.Listen(":3000")
}
```

---

We'll cover **unit tests, integration tests, middleware tests, table-driven tests, mocks, test organization, coverage, benchmarking, CI**, and practical examples using **Fiber**â€™s `app.Test()` and Goâ€™s `testing` package.

---

# 1) Testing philosophy & goals

* **Unit tests**: fast, isolated, no real DB or network. Test one function/handler behavior given controlled inputs (use mocks / fakes).
* **Integration tests**: test multiple components together (e.g., route + real DB or test DB). Slower but catch interaction bugs.
* **End-to-end tests**: full app running (usually in CI or a test environment).
* **Benchmarks**: measure performance of handlers or logic with `testing.B`.
* **Property of good tests**: deterministic, fast, readable, maintainable.

For Fiber, we avoid using `fiber.Ctx` across goroutines or keeping references after the handler returns â€” tests must respect the lifecycle.

---

# 2) Tools & libs we commonly use

* Standard: `testing`, `net/http/httptest`, `bytes`, `encoding/json`
* Assertion helpers: `github.com/stretchr/testify/assert` and `require`
* Mocks: hand-written fakes or `mockery`/`gomock` for interfaces
* DB test helpers: `sqlmock` for SQL, `mongo-go-driver` with local test DB or test containers for Mongo
* CI runners / Docker / Testcontainers for heavier integration tests

Install testify:

```bash
go get github.com/stretchr/testify
```

---

# 3) How to test Fiber handlers â€” basic structure

Two approaches:

A) **Handler directly** â€” call handler with a mocked `fiber.Ctx` (less common, more brittle).
B) **HTTP-style test** â€” create requests with `httptest.NewRequest` and call `app.Test(req, timeout)` â€” recommended, closer to real behavior.

Fiber exposes `app.Test` for this purpose.

### Minimal example (HTTP-style)

```go
// backend/handlers/hello.go
package handlers

import "github.com/gofiber/fiber/v2"

func Hello(c *fiber.Ctx) error {
    return c.JSON(fiber.Map{"message": "hello"})
}
```

```go
// backend/handlers/hello_test.go
package handlers

import (
    "net/http/httptest"
    "testing"
    "github.com/gofiber/fiber/v2"
    "github.com/stretchr/testify/assert"
)

func TestHello(t *testing.T) {
    app := fiber.New()
    app.Get("/hello", Hello)

    req := httptest.NewRequest("GET", "/hello", nil)
    resp, err := app.Test(req, -1) // -1 = no timeout
    assert.NoError(t, err)
    assert.Equal(t, 200, resp.StatusCode)
}
```

This style runs middleware + routing and is realistic.

---

# 4) Table-driven tests (Go idiom)

Great for many input variations.

```go
func TestHelloTable(t *testing.T) {
    app := fiber.New()
    app.Get("/echo", func(c *fiber.Ctx) error {
        return c.SendString(c.Query("q"))
    })

    tests := []struct{
        name string
        q    string
        want string
        code int
    }{
        {"empty", "", "", 200},
        {"hello", "hello", "hello", 200},
    }

    for _, tc := range tests {
        t.Run(tc.name, func(t *testing.T) {
            req := httptest.NewRequest("GET", "/echo?q="+tc.q, nil)
            resp, err := app.Test(req, -1)
            require.NoError(t, err)
            b, _ := io.ReadAll(resp.Body)
            assert.Equal(t, tc.want, string(b))
            assert.Equal(t, tc.code, resp.StatusCode)
        })
    }
}
```

---

# 5) Testing JSON bodies & parsing (`c.BodyParser`)

```go
func TestCreateTask(t *testing.T) {
    app := fiber.New()
    app.Post("/tasks", CreateTaskHandler)

    payload := `{"title":"buy milk","done":false}`
    req := httptest.NewRequest("POST", "/tasks", strings.NewReader(payload))
    req.Header.Set("Content-Type", "application/json")

    resp, err := app.Test(req, -1)
    require.NoError(t, err)
    assert.Equal(t, 201, resp.StatusCode)
    var got map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&got)
    assert.Equal(t, "buy milk", got["title"])
}
```

---

# 6) Testing middleware

We can assert middleware effects (headers, Locals, auth):

### Example: auth middleware sets `userID` in Locals

```go
func AuthMiddleware(c *fiber.Ctx) error {
    token := c.Get("Authorization")
    if token == "" { return c.Status(401).SendString("unauth") }
    c.Locals("userID", "u-1")
    return c.Next()
}

func TestAuthMiddleware(t *testing.T) {
    app := fiber.New()
    app.Use(AuthMiddleware)
    app.Get("/me", func(c *fiber.Ctx) error {
        id := c.Locals("userID").(string)
        return c.SendString(id)
    })

    // Missing token -> 401
    req := httptest.NewRequest("GET", "/me", nil)
    resp, _ := app.Test(req, -1)
    assert.Equal(t, 401, resp.StatusCode)

    // With token -> ok
    req = httptest.NewRequest("GET", "/me", nil)
    req.Header.Set("Authorization", "Bearer x")
    resp, _ = app.Test(req, -1)
    body, _ := io.ReadAll(resp.Body)
    assert.Equal(t, "u-1", string(body))
}
```

---

# 7) Testing file upload + download

**Upload (multipart/form-data)** â€” build a `multipart.Writer`.

```go
func TestUpload(t *testing.T) {
    app := fiber.New()
    app.Post("/upload", UploadHandler)

    var b bytes.Buffer
    w := multipart.NewWriter(&b)
    fw, _ := w.CreateFormFile("file", "test.txt")
    fw.Write([]byte("hello"))
    w.Close()

    req := httptest.NewRequest("POST", "/upload", &b)
    req.Header.Set("Content-Type", w.FormDataContentType())

    resp, _ := app.Test(req, -1)
    assert.Equal(t, 200, resp.StatusCode)
}
```

**Download** â€” assert `Content-Disposition` header and body.

```go
func TestDownload(t *testing.T) {
    app := fiber.New()
    app.Get("/download", func(c *fiber.Ctx) error {
        return c.Download("./testdata/sample.txt", "out.txt")
    })

    req := httptest.NewRequest("GET", "/download", nil)
    resp, _ := app.Test(req, -1)
    assert.Equal(t, 200, resp.StatusCode)
    assert.Contains(t, resp.Header.Get("Content-Disposition"), "attachment;")
}
```

---

# 8) Unit testing handlers with mocked services (dependency injection)

Best practice: make handlers depend on **interfaces** (service layer), so we can pass fakes in tests.

### Service interface

```go
type TaskService interface {
    Create(t Task) (Task, error)
    Get(id string) (Task, error)
}
```

### Handler factory

```go
type Handler struct { svc TaskService }

func NewHandler(s TaskService) *Handler { return &Handler{svc: s} }

func (h *Handler) CreateTask(c *fiber.Ctx) error {
    var t Task
    if err := c.BodyParser(&t); err != nil { return c.Status(400).SendString("bad") }
    created, err := h.svc.Create(t)
    if err != nil { return c.Status(500).SendString("err") }
    return c.Status(201).JSON(created)
}
```

### Fake in tests

```go
type fakeService struct{}
func (f fakeService) Create(t Task) (Task, error) {
    t.ID = "f-1"
    return t, nil
}

func TestCreateTaskUsingFake(t *testing.T) {
    app := fiber.New()
    h := NewHandler(fakeService{})
    app.Post("/tasks", h.CreateTask)

    req := httptest.NewRequest("POST", "/tasks", strings.NewReader(`{"title":"x"}`))
    req.Header.Set("Content-Type", "application/json")
    resp, _ := app.Test(req, -1)
    assert.Equal(t, 201, resp.StatusCode)
    var got Task
    json.NewDecoder(resp.Body).Decode(&got)
    assert.Equal(t, "f-1", got.ID)
}
```

This keeps tests isolated from DB.

---

# 9) Using `sqlmock` or test DBs for integration tests

* For SQL + GORM: `DATASTORE` interactions can be tested with `github.com/DATA-DOG/go-sqlmock`.
* For MongoDB: use a **test container** (Docker) or an ephemeral in-memory DB if available, or a local Mongo test instance.
* Alternative: in CI spin up databases via Docker Compose or Testcontainers.

Basic `sqlmock` pattern:

```go
db, mock, _ := sqlmock.New()
defer db.Close()
// expect query, return rows
mock.ExpectQuery("SELECT .* FROM tasks").WillReturnRows(sqlmock.NewRows([]string{"id","title"}).AddRow("1","x"))
// inject db into repository and run function
```

---

# 10) Error handling & assertions

Use `require` for fatal assertions (stop test on failure), `assert` for non-fatal.

```go
require.NoError(t, err) // stops test if err != nil
assert.Equal(t, want, got) // records failure but continues
```

---

# 11) Testing concurrency & avoiding pitfalls

* Donâ€™t share `fiber.Ctx` between goroutines â€” it may be reused.
* If a handler spawns goroutines, avoid using `c` inside them after handler returns. Instead copy needed values (e.g., `userID := c.Locals("userID")`) and pass those.
* In tests that check background processes, use synchronization (channels, WaitGroup) to make deterministic assertions.

---

# 12) Benchmarking with `testing.B`

We can benchmark handler logic (not full HTTP stack) or do `b.N` requests via `app.Test` for rough throughput (slower).

Example:

```go
func BenchmarkProcessTask(b *testing.B) {
    for i := 0; i < b.N; i++ {
        // measure the function that processes tasks (not network)
        ProcessTask(someInput)
    }
}
```

Run:

```bash
go test -bench . -benchmem
```

---

# 13) Test coverage, race detector, and flags

* Run all tests with verbose:

```bash
go test ./... -v
```

* Coverage:

```bash
go test ./... -coverprofile=cover.out
go tool cover -html=cover.out
```

* Race detector (helpful for concurrency bugs):

```bash
go test ./... -race
```

* Run a specific test:

```bash
go test -run TestCreateTask
```

---

# 14) CI practices

* Run `go test ./...` + `-race` in CI (if feasible).
* Generate coverage and fail build if coverage < threshold (custom script).
* For integration tests needing DB: use Docker Compose fixtures or Testcontainers; run them as separate job or in pre-step.

Example GitHub Actions step:

```yaml
- name: Run tests
  run: |
    go test ./... -v -coverprofile=cover.out
    go tool cover -func=cover.out | grep total | awk '{print $3}' | sed 's/%//' | xargs -I{} test "{}" -gt 80
```

(Weâ€™d adapt exact coverage check per project.)

---

# 15) Example: comprehensive test file for a CRUD handler

Below is a representative example that demonstrates many patterns (DI, table tests, JSON, assertions).

```go
// handlers/task_test.go
package handlers

import (
    "bytes"
    "encoding/json"
    "net/http/httptest"
    "testing"
    "github.com/gofiber/fiber/v2"
    "github.com/stretchr/testify/require"
)

type fakeSvc struct {}
func (f fakeSvc) Create(t Task) (Task, error) {
    t.ID = "f-1"
    return t, nil
}

func TestCreateTaskHandler(t *testing.T) {
    app := fiber.New()
    h := NewHandler(fakeSvc{})
    app.Post("/tasks", h.CreateTask)

    t.Run("valid payload", func(t *testing.T) {
        payload := Task{Title: "buy eggs"}
        b, _ := json.Marshal(payload)
        req := httptest.NewRequest("POST", "/tasks", bytes.NewReader(b))
        req.Header.Set("Content-Type", "application/json")

        resp, err := app.Test(req, -1)
        require.NoError(t, err)
        require.Equal(t, 201, resp.StatusCode)

        var got Task
        json.NewDecoder(resp.Body).Decode(&got)
        require.Equal(t, "f-1", got.ID)
        require.Equal(t, "buy eggs", got.Title)
    })

    t.Run("invalid json", func(t *testing.T) {
        req := httptest.NewRequest("POST", "/tasks", bytes.NewReader([]byte("{{bad")))
        req.Header.Set("Content-Type", "application/json")
        resp, _ := app.Test(req, -1)
        require.Equal(t, 400, resp.StatusCode)
    })
}
```

---

# 16) Advanced: testing error flows, timeouts, and context cancellation

* Test timeouts by injecting services that sleep longer than allowed.
* Use contexts for cancellation; ensure handlers respect cancellation signals.
* For long-running handlers, we can simulate `context.Context` with deadlines, but Fiber uses its own `Ctx`. For background tasks, use standard `context.Context` passed into services.

---

# 17) Test organization conventions

```
backend/
  handlers/
    task.go
    task_test.go
  service/
    task_service.go
    task_service_test.go
  repository/
    pg_repo.go
    pg_repo_test.go
  testdata/          # sample files
  mocks/             # auto-generated mocks if any
```

* Keep tests next to code (`*_test.go`) for discoverability.
* Use `testdata/` for static files used by tests.

---

# 18) Practical tips & gotchas

* **Donâ€™t rely on global state** (configs, DB connections) that tests mutate. If global is necessary, ensure setup/teardown resets them (`TestMain`).
* Use `t.Cleanup(...)` to guarantee cleanup (files, DB entries).
* When testing headers or cookies, inspect `resp.Header` and `resp.Cookies()` accordingly.
* Use `app.Test(req, -1)` for determinism; timeouts are useful if a handler may hang.
* If we test many handlers together, reuse a single `app` where appropriate but be mindful of stateful middleware.

---

# 19) Quick checklist when writing tests for Fiber apps

* [ ] Use dependency injection for DB/services.
* [ ] Prefer `app.Test` over constructing `fiber.Ctx` manually.
* [ ] Use `httptest.NewRequest` to build requests (JSON, multipart, etc.).
* [ ] Check status code, headers, and response body.
* [ ] Write table-driven tests for many cases.
* [ ] Mock external dependencies (DB, external APIs).
* [ ] Run `go test -race` locally for concurrent code.
* [ ] Add integration tests with a real/test DB in CI.
* [ ] Keep tests fast â€” move slow integration tests to separate suite.

---


